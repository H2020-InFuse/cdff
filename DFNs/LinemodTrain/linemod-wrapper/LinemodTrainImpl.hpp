/**
 * @addtogroup DFNs
 * @{
 */

#ifndef LINEMODTRAIN_LINEMODTRAINIMPL_HPP
#define LINEMODTRAIN_LINEMODTRAINIMPL_HPP

#include <opencv2/opencv.hpp>
#include <opencv2/rgbd/linemod.hpp>

#include <boost/serialization/map.hpp>
#include <boost/archive/text_oarchive.hpp>
#include <boost/archive/text_iarchive.hpp>

namespace CDFF
{
namespace DFN
{
namespace LinemodTrain
{

/*!
 * @brief This class implements a 3D mesh based detector based on LINEMOD.<br>
 * This detector uses template detection in the given image. It can estimate the pose of the object by using the pose used to train the template<br>
 */
class LinemodBasedPoseDetector
{
public:
    class CPoseRecord{
        public:
            unsigned int ui_objectId;
            unsigned int ui_templateId;
            int i_bbX, i_bbY, i_bbWidth, i_bbHeight; // bounding box generated by addTemplate
            double d_R1,d_R2,d_R3; // templates rotations in rodrigues form to save mem
            double d_T1,d_T2,d_T3; // translations
    private:
           friend class boost::serialization::access; // needed by Boost
           // When the class Archive corresponds to an output archive, the
           // & operator is defined similar to <<.  Likewise, when the class Archive
           // is a type of input archive the & operator is defined similar to >>.
           template<class Archive>
           void serialize(Archive& ar, const unsigned int version)
           {
               (void)(version);
               ar & ui_objectId;
               ar & ui_templateId;
               ar & i_bbX;
               ar & i_bbY;
               ar & i_bbWidth;
               ar & i_bbHeight;
               ar & d_R1;
               ar & d_R2;
               ar & d_R3;
               ar & d_T1;
               ar & d_T2;
               ar & d_T3;
           }
     };
     typedef std::map<int, CPoseRecord> TMapRecord;
    /*!
     * @brief Constructor
     */
    LinemodBasedPoseDetector();

    /*!
     * @brief Destructor
     */
    virtual ~LinemodBasedPoseDetector();

    /*!
     * @brief Initialize as a 2D only detector (only the color gradient modality is used)
     */
    void InitAs2D(int T_level0=5, int T_level1=8);

    /*!
     * @brief Initialize as a 3D detector (the color gradient modality and depth map is used)
     */
    void InitAs3D(int T_level0=5, int T_level1=8);

    /*!
     * @brief Save a training set
     * generate 2 files: one with "_training.dat" added to the argument and the other
     * with "_poses.dat" added to the argument
     * @param str_baseFullPathname Full base pathname for the files to be saved
     */
    void SaveTraining(const std::string& str_baseFullPathname);

    /*!
     * @brief Generate a training set
     * @param px_object 3D object to recognize
     */
    void Train(const std::string& ply_path, bool isPLY,
               float f_lonMin, float f_lonMax, float f_lonStep,
               float f_latMin, float f_latMax, float f_latStep,
               float f_angleMin, float f_angleMax, float f_angleStep,
               float f_radiusMin, float f_radiusMax, float f_radiusStep);

    /*!
     * @brief AddToTemplateBase
     * @param str_objName
     * @param ui_objectId
     * @param cvmat_image
     * @param cvmat_mask
     * @param vec_R
     * @param vec_T
     * @return
     */
    bool AddToTemplateBase(const std::string &str_objName, unsigned int ui_objectId, const std::vector<cv::Mat> &sources,
                           const cv::Mat& cvmat_mask, const cv::Vec3d &vec_R, const cv::Vec3d &vec_T);

    int _num_modalities;
    unsigned int _ui_numberOfTemplates;
    cv::Ptr<cv::linemod::Detector> _cvptr_detector;
    TMapRecord _x_poseMap;
    double _winW;
    double _winH;
    double _fx;
    double _fy;
    double _cx;
    double _cy;
    std::string _saveDir;
};

}
}
}
#endif // LINEMODTRAIN_LINEMODTRAINIMPL_HPP

/** @} */
