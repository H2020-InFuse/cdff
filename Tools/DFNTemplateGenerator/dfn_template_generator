#!/usr/bin/env python3
import os
import argparse
import yaml
import jinja2


class TypeRegistry(object):  # TODO global, read from config files
    """Registry for InFuse type information."""
    def __init__(self):
        self.cache = {}

    def get_info(self, typename):
        if typename.startswith("base"):
            if typename not in self.cache:
                self.cache[typename] = BaseTypeInfo(typename)
            return self.cache[typename]
        else:
            raise NotImplementedError("No type info for '%s' available."
                                      % typename)


class BaseTypeInfo(object):
    """Information about InFuse base types."""
    def __init__(self, typename):
        self.typename = typename

    def include(self):
        """C++ include header."""
        return self.typename.replace("::", "/") + ".hpp"

    def cython_type(self):
        return self.typename.replace(
            "base::", "_basetypes.").replace("samples::", "")

    def python_type(self):
        return self.typename.replace(
            "base::", "basetypes.").replace("samples::", "")


def main():
    args = parse_args()
    with open(args.definition, "r") as f:
        node = yaml.load(f)

    type_registry = TypeRegistry()
    src_dir = os.path.join(args.output, "src")
    python_dir = os.path.join(args.output, "python")
    if not os.path.exists(src_dir):
        os.makedirs(src_dir)
    if not os.path.exists(python_dir):
        os.makedirs(python_dir)
    write_class(
        node, type_registry, "Interface", "Interface", target_folder=src_dir,
        force_overwrite=True)
    write_class(
        node, type_registry, "Node", "", target_folder=src_dir)
    write_cython(node, type_registry, "Node", target_folder=python_dir)


def parse_args():
    argparser = argparse.ArgumentParser(description="DFN template generator")
    argparser.add_argument("definition", type=str, help="Node definition")
    argparser.add_argument("output", type=str, help="Target directory",
                           nargs="?", default=".")
    return argparser.parse_args()


def write_class(node, type_registry, template_base, file_suffix,
                target_folder="src", force_overwrite=False):
    result = {}

    declaration_filename = "%s%s.hpp" % (node["name"], file_suffix)
    definition_filename = "%s%s.cpp" % (node["name"], file_suffix)

    includes = set()
    for port in node["input_ports"]:
        includes.add(type_registry.get_info(port["type"]).include())
    for output_port in node["output_ports"]:
        includes.add(type_registry.get_info(port["type"]).include())

    node_base_declaration = render(
        "templates/%s.hpp.template" % template_base,
        node=node, includes=includes)
    target = os.path.join(target_folder, declaration_filename)
    result[target] = node_base_declaration

    node_base_definition = render(
        "templates/%s.cpp.template" % template_base,
        declaration_filename=declaration_filename, node=node)
    target = os.path.join(target_folder, definition_filename)
    result[target] = node_base_definition

    write_result(result, force_overwrite)


def write_cython(node, type_registry, template_base,
                 target_folder="python_binding"):
    result = {}

    pxd_filename = "dfn_ci_%s.pxd" % (node["name"].lower())
    _pxd_filename = "_dfn_ci_%s.pxd" % (node["name"].lower())
    pyx_filename = "dfn_ci_%s.pyx" % (node["name"].lower())

    pxd_file = render(
        "templates/%s.pxd.template" % template_base, node=node)
    target = os.path.join(target_folder, pxd_filename)
    result[target] = pxd_file

    _pxd_file = render(
        "templates/_%s.pxd.template" % template_base, node=node)
    target = os.path.join(target_folder, _pxd_filename)
    result[target] = _pxd_file

    pyx_file = render(
        "templates/%s.pyx.template" % template_base, node=node,
        type_registry=type_registry)
    target = os.path.join(target_folder, pyx_filename)
    result[target] = pyx_file

    write_result(result, True)


def render(template_filename, **kwargs):
    if not os.path.exists(template_filename):
        raise IOError("No template for '%s' found." % template)
    with open(template_filename, "r") as template_file:
        template = jinja2.Template(template_file.read())
    return template.render(**kwargs)


def write_result(result, force_overwrite):
    msg = ""
    for filename, content in result.items():
        if os.path.exists(filename):
            if msg:
                msg += os.linesep
            msg += "File '%s' exists already." % filename
            if force_overwrite:
                msg += " Overwriting."
            else:
                msg += " Not written."

            write = force_overwrite
        else:
            write = True

        if write:
            with open(filename, "w") as f:
                f.write(content)

    if msg:
        print(msg)


if __name__ == "__main__":
    main()

