/*
* Copyright (c) 2008-2012 Semantix and (c) 2012-2015 Neuropublic
*
* This file is part of the ASN1SCC tool.
*
* Licensed under the terms of GNU General Public Licence as published by
* the Free Software Foundation.
*
*  For more informations see License.txt file
*/

group spark_spec;



PrintFile(arrsPackages) ::= <<
<arrsPackages; separator="\n\n">
>>


rtlModuleName() ::= "adaasn1rtl"

PrintPackageSpec(sPackageName, arrsIncludedModules, arrsTypeAssignments, arrsValueAssignments, arrsPrivateChoices) ::= <<
-- Code automatically generated by asn1scc tool
WITH <rtlModuleName()>;
USE <rtlModuleName()>;
use type <rtlModuleName()>.OctetBuffer;
use type <rtlModuleName()>.BitArray;
use type <rtlModuleName()>.Asn1UInt;
use type <rtlModuleName()>.Asn1Int;
use type <rtlModuleName()>.BIT;
<rest(arrsIncludedModules):{inc| WITH <inc>;}; separator="\n">
--# inherit <arrsIncludedModules:{inc| <inc>}; separator=",">;


PACKAGE <sPackageName>
IS


<arrsTypeAssignments:{tas|<tas>}; separator="\n">

<arrsValueAssignments:{vas|<vas>}; separator="\n"> 

private
   --# hide <sPackageName>;

   <arrsPrivateChoices; separator="\n">

END <sPackageName>;
>>


PrintNegativeRealConstant(sName, sValue) ::= "<sName>:CONSTANT <rtlModuleName()>.Asn1Real := <sValue>;"

PrintPackageBody(sPackageName, arrsIncludedModules, arrsNegativeReals, arrsBoolPatterns, arrsTypeAssignments, arrsChoiceValueAssignments) ::= <<
-- Code automatically generated by asn1scc tool
<arrsIncludedModules:{inc| WITH <inc>;}; separator="\n">
use type <rtlModuleName()>.Asn1UInt;
use type <rtlModuleName()>.Asn1Int;
use type <rtlModuleName()>.BIT;


PACKAGE BODY <sPackageName> IS

<arrsNegativeReals; separator="\n\n">

<arrsBoolPatterns; separator="\n\n">

<arrsTypeAssignments:{tas|<tas>}; separator="\n\n">

<arrsChoiceValueAssignments:{vas|<vas>}; separator="\n\n"> 

END <sPackageName>;
>>



PrintValueAssignment(sVasName, sTypeDecl, sValue) ::= <<
<sVasName> : CONSTANT <sTypeDecl>:= <sValue>;
>>

PrintValueAssignment_Choice(sVasName, sTypeDecl, sValue) ::= "FUNCTION <sVasName> RETURN <sTypeDecl>;"

PrintValueAssignment_Choice_body(sVasName, sTypeDecl, sValue) ::= <<
FUNCTION <sVasName> RETURN <sTypeDecl>
IS --# hide <sVasName>;
BEGIN
    RETURN <sValue>;
END <sVasName>;
>>


PrintTypeAssignment(sName, sTasDecl, nMaxBitsInPER, nMaxBytesInPER, nMaxBitsInACN, nMaxBytesInACN, arrsErrorCodes, bGenIsValid, bGenEqual, arrsEncPrototypes, bIsComplex) ::= <<
-----------------------------------------------------------<sName>-------------------------------------------------------------
<sTasDecl>

<sName>_REQUIRED_BYTES_FOR_ENCODING:CONSTANT INTEGER := <nMaxBytesInPER>;
<sName>_REQUIRED_BITS_FOR_ENCODING:CONSTANT INTEGER := <nMaxBitsInPER>;
<sName>_REQUIRED_BYTES_FOR_ACN_ENCODING:CONSTANT INTEGER := <nMaxBytesInACN>;
<sName>_REQUIRED_BITS_FOR_ACN_ENCODING:CONSTANT INTEGER := <nMaxBitsInACN>;
<sName>_REQUIRED_BYTES_FOR_XER_ENCODING:CONSTANT INTEGER :=  0;

FUNCTION <sName>_Init return <sName>;
---# derives val from;
<if(bGenIsValid)>
FUNCTION <sName>_IsConstraintValid(val : in <sName>) return <rtlModuleName()>.ASN1_RESULT;
---# derives result from val;

<endif>
<if(bGenEqual)>
FUNCTION <sName>_Equal(val1, val2: in <sName>) return Boolean;

<if(bIsComplex)>
FUNCTION "=" (val1, val2: in <sName>) return Boolean renames <sName>_Equal;
<endif>

<endif>

<arrsEncPrototypes: {pr|<pr>}; separator="\n">

<arrsErrorCodes: {pr|<pr>}; separator="\n">

>>


PRIMITIVE_tas_decl(sName, sTypeDecl) ::= <<
SUBTYPE <sName> IS <sTypeDecl>;
>>

SEQUENCE_tas_decl_child_bit(sName) ::= "<sName>:<rtlModuleName()>.BIT;"

SEQUENCE_tas_decl_child(sName, sType) ::= "<sName> : <sType>;"

SEQUENCE_tas_decl(sName, arrsChildren, arrsOptionalChildren) ::= <<
<if(arrsChildren)>
<if (arrsOptionalChildren)>
TYPE <sName>_EXIST IS RECORD
    <arrsOptionalChildren; separator="\n">
END RECORD;

<endif>
TYPE <sName> IS RECORD 
    <arrsChildren; separator="\n">
    <if (arrsOptionalChildren)>
    
    Exist : <sName>_EXIST;

    <endif>
END RECORD;
<else>
TYPE <sName> IS RECORD 
    null;
END RECORD;
<endif>
>>



CHOICE_tas_decl_child(sTasName, sName, sType, sNamePresent) ::= <<
FUNCTION <sTasName>_<sName>_get(val:<sTasName>) RETURN <sType>;
--# pre <sTasName>_kind(val) = <sNamePresent>;
FUNCTION <sTasName>_<sName>_set(itm:<sType>) RETURN <sTasName>;
>>


CHOICE_tas_decl(sName, arrsChildren, arrsPresent, nIndexMax) ::= <<
TYPE <sName> IS PRIVATE;
SUBTYPE <sName>_index_range is integer range 0..<nIndexMax>;

TYPE <sName>_selection IS (<arrsPresent; separator=", ">);
for <sName>_selection use
    (<arrsPresent:{c|<c> => <i>}; separator=", ">);
for <sName>_selection'Size use 32;


-- getters and setters
FUNCTION <sName>_kind(val:<sName>) RETURN <sName>_selection;
<arrsChildren; separator="\n">
>>

CHOICE_tas_decl_priv_child(sName, sType, sPresent) ::=<<
when <sPresent> =>
        <sName>: <sType>;
>>
CHOICE_tas_decl_priv(sName, sFirstChildNamePresent, arrsChildren) ::= <<
TYPE <sName>(kind : <sName>_selection:= <sFirstChildNamePresent>) IS 
RECORD
    case kind is
    <arrsChildren; separator="\n">
    end case;
END RECORD;

FOR <sName> USE 
RECORD
    kind AT 0 RANGE 0..31;
END RECORD;
>>

SEQUENCE_OF_tas_decl(sName, nMin, nMax, bFixedSize, sChildType) ::= <<
SUBTYPE <sName>_index is integer range 1..<nMax>;
TYPE <sName>_array IS ARRAY (<sName>_index) OF <sChildType>;
<if(!bFixedSize)>SUBTYPE <sName>_length_index is integer range <nMin>..<nMax>;<endif>
TYPE <sName> IS  RECORD
<if(!bFixedSize)>    Length : <sName>_length_index;<endif>
    Data  : <sName>_array;
END RECORD;
>>


BIT_STRING_tas_decl(sName, nMin, nMax, bFixedSize) ::= <<
SUBTYPE <sName>_index is integer range 1..<nMax>;
SUBTYPE <sName>_array IS <rtlModuleName()>.BitArray(<sName>_index);
<if(!bFixedSize)>SUBTYPE <sName>_length_index is integer range <nMin>..<nMax>;<endif>
TYPE <sName> IS  RECORD
<if(!bFixedSize)>    Length : <sName>_length_index;<endif>
    Data  : <sName>_array;
END RECORD;
>>

OCTET_STRING_tas_decl(sName, nMin, nMax, bFixedSize) ::= <<
SUBTYPE <sName>_index is integer range 1..<nMax>;
SUBTYPE <sName>_array IS <rtlModuleName()>.OctetBuffer(<sName>_index);
<if(!bFixedSize)>SUBTYPE <sName>_length_index is integer range <nMin>..<nMax>;<endif>
TYPE <sName> IS  RECORD
<if(!bFixedSize)>    Length : <sName>_length_index;<endif>
    Data  : <sName>_array;
END RECORD;
>>

/* nCMax = nMax + 1*/
IA5STRING_OF_tas_decl(sName, nMin, nMax, nCMax, arrnAlphaChars) ::= <<
SUBTYPE <sName>_encoding_range is integer range <nMin>..<nMax>;
SUBTYPE <sName>_index is integer range 1..<nCMax>;
SUBTYPE <sName> IS String(<sName>_index);
<if(arrnAlphaChars)>
SUBTYPE <sName>_alpha_index is integer range 1..<arrnAlphaChars.Length>;
SUBTYPE <sName>_alpha IS String(<sName>_alpha_index);
<sName>_alpha_set : constant <sName>_alpha := <sName>_alpha'(<arrnAlphaChars:{c|<i>=>Character'Val(<c>)}; wrap, anchor,  separator=", ">);

<endif>
>>

ENUMERATED_tas_decl_item(sName, nValue) ::= "<sName> => <nValue>"
ENUMERATED_tas_decl(sName, arrsEnumNames, arrsEnumNamesAndValues, nIndexMax) ::= <<
SUBTYPE <sName>_index_range is integer range 0..<nIndexMax>;
TYPE <sName> IS (<arrsEnumNames; separator=", ">);
for <sName> use
    (<arrsEnumNamesAndValues; separator=", ">);
for <sName>'Size use 32;
>>


UPER_annotations_encode(sName, bKDependsOnValue, bAcnEncodeFuncRequiresResult, bResDependsOnData, bKDependsOnData) ::= <<
--# derives S from S , K, val & K from K<if(bKDependsOnValue)>, val<endif><if(bAcnEncodeFuncRequiresResult)> & result from val <endif>;
--# pre K+1>= S'First and K + <sName>_REQUIRED_BITS_FOR_ENCODING \<= S'Last;
--# post K>=K~ and K\<=K~+<sName>_REQUIRED_BITS_FOR_ENCODING;
>>
UPER_annotations_decode(sName, bKDependsOnValue, bAcnEncodeFuncRequiresResult, bResDependsOnData, bKDependsOnData) ::= <<
--# derives val from S , K &
--#         K from K <if(bKDependsOnData)>,S<endif> & result from K<if(bResDependsOnData)>,S<endif>;
--# pre K.K+1>= S'First and K.K + <sName>_REQUIRED_BITS_FOR_ENCODING \<= S'Last;
--# post K.K>=K~.K and K.K\<=K~.K+<sName>_REQUIRED_BITS_FOR_ENCODING;
>>



UPER_encPrototypes(sName, bEmptyEncodingSpace, bKDependsOnValue, bAcnEncodeFuncRequiresResult, bResDependsOnData, bKDependsOnData) ::= <<
SUBTYPE <sName>_uPER_bit_array_range is Natural range 1..<if(bEmptyEncodingSpace)>1<else><sName>_REQUIRED_BITS_FOR_ENCODING<endif>;
SUBTYPE <sName>_uPER_bit_array is <rtlModuleName()>.BitArray(<sName>_uPER_bit_array_range);

TYPE <sName>_uPER_Stream IS RECORD
    K	: Natural;
    DataLen	: Natural;
    Data : <sName>_uPER_bit_array;
END RECORD;
PROCEDURE <sName>_uPER_Encode(val:in <sName>; Stream : OUT <sName>_uPER_Stream<if(bAcnEncodeFuncRequiresResult)>; result : OUT <rtlModuleName()>.ASN1_RESULT<endif>);
--# derives Stream from val<if(bAcnEncodeFuncRequiresResult)> & result from val <endif>;
PROCEDURE <sName>_uPER_Decode(val: out <sName>; Stream : IN <sName>_uPER_Stream; result : OUT <rtlModuleName()>.ASN1_RESULT);
--# derives val from Stream & result from Stream;

PROCEDURE <sName>_uPER_Encode_aux(val:in <sName>; S : in out <rtlModuleName()>.BitArray; K : in out Natural<if(bAcnEncodeFuncRequiresResult)>; result : OUT <rtlModuleName()>.ASN1_RESULT<endif>);
<UPER_annotations_encode(sName=sName, bKDependsOnValue=bKDependsOnValue, bAcnEncodeFuncRequiresResult= bAcnEncodeFuncRequiresResult, bResDependsOnData=bResDependsOnData, bKDependsOnData=bKDependsOnData)>
PROCEDURE <sName>_uPER_Decode_aux(val: out <sName>; S : in <rtlModuleName()>.BitArray; K : in out <rtlModuleName()>.DECODE_PARAMS; result : OUT <rtlModuleName()>.ASN1_RESULT);
<UPER_annotations_decode(sName=sName, bKDependsOnValue=bKDependsOnValue, bAcnEncodeFuncRequiresResult= bAcnEncodeFuncRequiresResult, bResDependsOnData=bResDependsOnData, bKDependsOnData=bKDependsOnData)>
>>



ExtraParams(extraPrms) /*nogen*/ ::= "<if(extraPrms)>, <extraPrms; separator=\", \"><endif>"

/* arrsEncDecInOutPrmsNames */

ACN_encPrototypes(sName, bEmptyEncodingSpace, bKDependsOnValue, bAcnEncodeFuncRequiresResult, bResDependsOnData, bKDependsOnData, arrsExtraEncParams, arrsExtraDecParams, arrsDecInParamNames, arrsEncDecInOutPrmsNames, arrsEncDecInOutPrmsNames_noBools, arrsUpdatePrototypes) ::= <<
SUBTYPE <sName>_ACN_bit_array_range is Natural range 1..<if(bEmptyEncodingSpace)>1<else><sName>_REQUIRED_BITS_FOR_ACN_ENCODING<endif>;
SUBTYPE <sName>_ACN_bit_array is <rtlModuleName()>.BitArray(<sName>_ACN_bit_array_range);

TYPE <sName>_ACN_Stream IS RECORD
    K	: Natural;
    DataLen	: Natural;
    Data : <sName>_ACN_bit_array;
END RECORD;
PROCEDURE <sName>_ACN_Encode(val:in <sName>; Stream : OUT <sName>_ACN_Stream<if(bAcnEncodeFuncRequiresResult)>; result : OUT <rtlModuleName()>.ASN1_RESULT<endif><if(arrsExtraEncParams)>; <arrsExtraEncParams;separator="; "><endif>);
--# derives Stream from val<ExtraParams(arrsEncDecInOutPrmsNames)> <if(bAcnEncodeFuncRequiresResult)>& result from val<ExtraParams(arrsEncDecInOutPrmsNames_noBools)><endif>;
PROCEDURE <sName>_ACN_Decode(val: out <sName>; Stream : IN <sName>_ACN_Stream; result : OUT <rtlModuleName()>.ASN1_RESULT<if(arrsExtraDecParams)>; <arrsExtraDecParams;separator="; "><endif>);
--# derives val<ExtraParams(arrsEncDecInOutPrmsNames)> from Stream<ExtraParams(arrsDecInParamNames)> & result from Stream<ExtraParams(arrsDecInParamNames)>;

PROCEDURE <sName>_ACN_Encode_aux(val:in <sName>; S : in out <rtlModuleName()>.BitArray; K : in out Natural<if(bAcnEncodeFuncRequiresResult)>; result : OUT <rtlModuleName()>.ASN1_RESULT<endif><if(arrsExtraEncParams)>; <arrsExtraEncParams;separator="; "><endif>);
<ACN_annotations_encode(sName=sName, bKDependsOnValue=bKDependsOnValue, bAcnEncodeFuncRequiresResult=bAcnEncodeFuncRequiresResult, bResDependsOnData=bResDependsOnData, bKDependsOnData=bKDependsOnData, arrsEncDecInOutPrmsNames=arrsEncDecInOutPrmsNames, arrsEncDecInOutPrmsNames_noBools=arrsEncDecInOutPrmsNames_noBools)>

PROCEDURE <sName>_ACN_Decode_aux(val: out <sName>; S : in <rtlModuleName()>.BitArray; K : in out <rtlModuleName()>.DECODE_PARAMS; result : OUT <rtlModuleName()>.ASN1_RESULT<if(arrsExtraDecParams)>; <arrsExtraDecParams;separator="; "><endif>);
<ACN_annotations_decode(sName=sName, bKDependsOnValue=bKDependsOnValue, bAcnEncodeFuncRequiresResult=bAcnEncodeFuncRequiresResult, bResDependsOnData=bResDependsOnData, bKDependsOnData=bKDependsOnData, arrsDecInParamNames=arrsDecInParamNames, arrsEncDecInOutPrmsNames=arrsEncDecInOutPrmsNames, arrsEncDecInOutPrmsNames_noBools=arrsEncDecInOutPrmsNames_noBools)>

<arrsUpdatePrototypes; separator="\n\n">
>>

ACN_annotations_encode(sName, bKDependsOnValue, bAcnEncodeFuncRequiresResult, bResDependsOnData, bKDependsOnData, arrsDecInParamNames, arrsEncDecInOutPrmsNames, arrsEncDecInOutPrmsNames_noBools) ::= <<
--# derives   S from S , K, val<ExtraParams(arrsEncDecInOutPrmsNames)> & 
--#           K from K<if(bKDependsOnValue)>, val<ExtraParams(arrsEncDecInOutPrmsNames_noBools)><endif><if(bAcnEncodeFuncRequiresResult)> & result from val<ExtraParams(arrsEncDecInOutPrmsNames_noBools)><endif>;
--# pre K+1>= S'First and K + <sName>_REQUIRED_BITS_FOR_ACN_ENCODING \<= S'Last;
--# post K>=K~ and K\<=K~+<sName>_REQUIRED_BITS_FOR_ACN_ENCODING;
>>

ACN_annotations_decode(sName, bKDependsOnValue, bAcnEncodeFuncRequiresResult, bResDependsOnData, bKDependsOnData, arrsDecInParamNames, arrsEncDecInOutPrmsNames, arrsEncDecInOutPrmsNames_noBools) ::= <<
--# derives val<ExtraParams(arrsEncDecInOutPrmsNames)>      from S, K<ExtraParams(arrsDecInParamNames)> &
--#         K        from K<if(bKDependsOnData)>, S<endif><ExtraParams(arrsDecInParamNames)> & 
--#         result   from K<if(bResDependsOnData)>, S<endif><ExtraParams(arrsDecInParamNames)>;
--# pre K.K+1>= S'First and K.K + <sName>_REQUIRED_BITS_FOR_ACN_ENCODING \<= S'Last;
--# post K.K>=K~.K and K.K\<=K~.K+<sName>_REQUIRED_BITS_FOR_ACN_ENCODING;
---- bKDependsOnData = <bKDependsOnData>
>>


Acn_update_param_protorype(sTasName, bHasSuccess, sParamName, sParamType) ::= <<
PROCEDURE <sTasName>_ACN_Encode_update_<sParamName>(val : IN <sTasName>; <sParamName>: OUT <sParamType><if(bHasSuccess)>; result : OUT <rtlModuleName()>.ASN1_RESULT<endif>);
--# derives <sParamName><if(bHasSuccess)>, result<endif> from val;
>>



PrintErrorCode(sErrorName, nErrCode, sComment) ::= "<sErrorName>:CONSTANT INTEGER := <nErrCode>; -- <sComment>"

Declare_spark_Integer() ::="<rtlModuleName()>.Asn1Int"
Declare_Integer() ::="<rtlModuleName()>.Asn1Int"
Declare_Integer_min_max(nMin, nMax) ::="<rtlModuleName()>.Asn1Int range <nMin>..<nMax>"
Declare_Integer_posInf(nMin) ::="<rtlModuleName()>.Asn1Int range <nMin>..<rtlModuleName()>.Asn1Int'Last"
Declare_Integer_negInf(nMax) ::="<rtlModuleName()>.Asn1Int range <rtlModuleName()>.Asn1Int'First..<nMax>"
Declare_Integer_Empty() ::= "<rtlModuleName()>.Asn1Int WARNING this type has constraints that do not allow any values"


Declare_BOOLEAN() ::= "<rtlModuleName()>.Asn1Boolean"

Declare_REAL() ::= "<rtlModuleName()>.Asn1Real"

Declare_NULL() ::= "<rtlModuleName()>.Asn1NullType"

Declare_Reference1(sName) ::= "<sName>"
Declare_Reference2(sModName,sName) ::= "<sModName>.<sName>"

