group vdm;

//delimiters "$", "$"

/* VDM (Vienna Development Method) backend for ASN.1 data types

  (c) 2015 European Space Agency
*/


/* Header of the file */
RootXml(arrsFiles) ::= <<
$arrsFiles;separator="\n"$
>>


/* sFileName is a string with the current file name */
FileXml(sFileName, arrsModules) ::= <<
$arrsModules;separator="\n"$
>>


/* Per ASN.1 module. you can use:
  - the module name (sName, sCName is the same but using underscores)
  - the list of types that are exported by this module.
    Example of use:
    $arrsExpTypes:{x|"$x$"};separator=", "$
  - the list of variables that are exported by this module (arrsExpVars)
  - the list of imported modules (generated by template ImportedMod)
 Then you can use the list of types and variables defined in this module
 arrsTases is an array of strings generated by template TasXml
 arrsVases is an array of strings generated by template VasXml
*/
ModuleXml(sName, sCName, arrsImportedModules, arrsExpTypes, arrsExpVars, arrsTases, arrsVases) ::= <<
class $sCName$

types
    $arrsTases;separator=";\n\n"$

values
    $arrsVases;separator=";\n\n"$

end $sCName$
>>


/* An imported module with a list of imported types and variables */
ImportedMod(sName, sCName, arrsTypes, arrsVars) ::= ""


/* A single Type Assignment, this is filled for all types of all modules.
Use sCName which is the type name using underscores in place of dashes
*/
TasXml(sName, nLine, nPos, sType, sCName, sAssigOp, sContract) ::= <<
public $sCName$ $sAssigOp$ $sType$$sContract$
>>


/* A single Variable Assignment */
VasXml(sName, nLine, nPos, sType, sValue, sCName) ::= <<
public $sCName$ : $sType$ = $sValue$
>>

TypeGeneric(nLine, nPos, sSubType) ::= <<
$sSubType$
>>

/* Type with Min and Max constraint. sName is the type kind
   This template is used for Integer and Real types; for others,
   see MinMaxType2 */
MinMaxType(sName, sMin, sMax, bFixedSize) ::= <<
$sName$
>>

/* String types with size constraint: Bitstring, Octetstring, Ia5String,
   NumericString */
MinMaxType2(sName, sMin, sMax, bFixedSize) ::= <<
$sName$
>>

BooleanType () ::= "bool"

NullType () ::= "nil"

IntegerType () ::= "int"

RealType () ::= "real"

BitStringType () ::= "seq of bool"

/* Octet string in VDM mapped to sequence of characters */
OctetStringType () ::= "seq of char"

IA5StringType () ::= "seq of char"

NumericStringType () ::= "seq of char"

AssigOpNormalType () ::= "="
AssigOpSpecialType () ::= "::"


/* Enumerated item, note the difference between sName and sCID:
   sName is the enumerated name given in the input type, e.g. if you have
   MyType ::= ENUMERATED { a, b, c } then sName can be a, b or c
   and sCID which is a name built by the parser for removing ambiguities in
   some languages, e.g. if you have two types with the same enumerated name:
   MyOtherType ::= ENUMERATED { b, x, y }
   When this case happens, sCID will be either "MyType_b" or "MyOtherType_b"
   Check if your language needs this or not (C does, Ada does not)
   note: the renaming policy can be controlled with the command line of asn1scc
   for VDM: assuming sCID, to be checked
   nVal is the integer value of the enumerated, use it if needed
*/
EnumItem (sName, sCName, nVal, nLine, nPos, sCID) ::= <<
<$sCID$>
>>

/* Enumerated type: arrsItems is an array of EnumItem */
EnumType(arrsItems) ::= <<
$arrsItems;separator=" | "$
>>


/* Choice field
   Choice are discriminated unions, they have a name per field and a type :
   MyCHOICE ::= CHOICE {
       choice-a   Type-of-A,   -- choice-a is sName, choice_a is sCName
       choice-b   Type-of-B,
       ...
  }
  sNamePresent is an unambiguous name to access the field
*/
ChoiceChild(sName, sCName, nLine, nPos, sChildContent, sNamePresent ) ::= <<
$sChildContent$
>>

/* Full choice type: in VDM, should be <Type-of-A> | <Type-of-B> | ... */
ChoiceType(arrsChildren) ::= <<
$arrsChildren;separator=" | "$
>>


/* Sequence (record) field. May be optional and may have a default value */
SequenceChild(sName, sCName, bOptional, sDefVal, nLine, nPos, sChildContent ) ::= <<
$sCName$ : $sChildContent$
>>

/* Full sequence (record) type */
SequenceType(arrsChildren) ::= <<

    $arrsChildren;separator="\n"$
>>

/* Sequence of (array) */
SequenceOfType(sMin, sMax, sChild) ::= <<
seq of $sChild$
>>

/* Reference to another type, with Min/Max subtype
   Could be in a different module */
RefTypeMinMax(sMin, sMax, sName, sModName, sCName, sCModName) ::= <<
$if(sCModName)$$sCModName$`$endif$$sCName$
>>

/* Reference to another type */
RefType(sName, sModName, sCName, sCModName) ::= <<
$if(sCModName)$$sCModName$`$endif$$sCName$
>>


/* VDM allows declaration of constraints on types */
Contract(sTypePattern, sExpr) ::= <<
$if(sTypePattern)$
$if(sExpr)$

inv $sTypePattern$ ==
    $sExpr$
$endif$
$endif$
>>

/* Type pattern is used for pattern matching of the contract. In VDM it maps
   to an instance of the type, e.g:
   MyType = nat
   inv inst >= 10 and inst <= 100   -- inst is the type pattern
*/
TypePatternCommonTypes() ::= "x"

/* Records have a more complex pattern in VDM: mk_Type(field1, ...) */
TypePatternSequence(sName, sCName, arrsChildren) ::= <<
mk_$sCName$($arrsChildren;separator=", "$)
>>

/* Name used in the Sequence pattern to identify field names */
SequencePatternChild(sName, sCName) ::= "$sCName$"

ContractExprMinMax(sPattern, sMin, sMax, bFixedSize) ::= <<
$sPattern$ >= $sMin$ and $sPattern$ <= $sMax$
>>

ContractExprSize(sPattern, sMin, sMax, bFixedSize) ::= <<
$if(bFixedSize)$
len $sPattern$ = $sMin$
$else$
len $sPattern$ >= $sMin$ and len $sPattern$ <= $sMax$
$endif$
>>

ContractExprSequence(arrsChildren) ::= <<
$arrsChildren;separator=" and "$
>>

/* Print Values */
Print_IntegerValue(nVal) ::= "$nVal$"
Print_RealValue(dVal) ::= "$dVal$"
Print_StringValue(v) ::= <<"$v$">>
Print_TrueValue() ::= "true"
Print_FalseValue() ::= "false"
Print_BitStringValue(v) ::= "$v$"
Print_OctetStringValue(arruOctets) ::= <<'$arruOctets:{b|<b;format="X2">}$>>
Print_RefValue(sName) ::= "<$sName$>"
Print_SeqOfValue(arrsValues) ::= <<[$arrsValues; separator=", "$]>>
Print_SeqValue_Child(sName, sChildValue) ::= "undefined"
Print_SeqValue(arrsValues) ::= "undefined"
Print_ChValue(sAltName,sAltValue) ::= "$sAltValue$"
Print_NullValue() ::= "nil"


