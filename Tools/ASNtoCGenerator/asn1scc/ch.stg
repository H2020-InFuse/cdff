/*
* Copyright (c) 2008-2012 Semantix and (c) 2012-2015 Neuropublic
*
* This file is part of the ASN1SCC tool.
*
* Licensed under the terms of GNU General Public Licence as published by
* the Free Software Foundation.
*
*  For more informations see License.txt file
*/

group ch ;

PrintHeaderFile(sFileNameWithNoExtUpperCase, arrsIncludedModules, arrsTypeAssignments, arrsValueAssignments, arrsPrototypes, arrsUtilityDefines) ::= <<
#ifndef GENERATED_ASN1SCC_<sFileNameWithNoExtUpperCase>_H
#define GENERATED_ASN1SCC_<sFileNameWithNoExtUpperCase>_H
/*
Code automatically generated by asn1scc tool
*/
<arrsIncludedModules:{inc| #include "<inc>.h"}; separator="\n">
#include "asn1crt.h"

#ifdef  __cplusplus
extern "C" {
#endif


<arrsTypeAssignments:{tas|<tas>}; separator="\n">

<arrsValueAssignments:{vas|<vas>}; separator="\n"> 

/* ================= Encoding/Decoding function prototypes =================
 * These functions are placed at the end of the file to make sure all types
 * have been declared first, in case of parameterized ACN encodings
 * ========================================================================= */

<arrsPrototypes:{proto|<proto>}; separator="\n"> 


#ifdef  __cplusplus
}
<arrsUtilityDefines; separator="\n">

#endif

#endif

>>

EnumUtilDefine(sItemName) ::= "#define ENUM_<sItemName>	<sItemName>"

EnumInnerUtilDefine(sTasName, sItemName) ::= "#define ENUM_<sItemName>	<sTasName>::<sItemName>"

ChoiceUtilDefine(sTasName, sChildNamePresent) ::= "#define CHOICE_<sChildNamePresent>	<sTasName>::<sChildNamePresent>"

PrintValueAssignment(sTypeDecl, sName) ::= "extern const <sTypeDecl> <sName>;"

PrintTypeAssignment(sTypeDecl, sArrayPostfix, sName, nMaxBitsInPER, nMaxBytesInPER, nMaxBitsInACN, nMaxBytesInACN, nMaxBytesInXER, sStar, bGenEqual, arrsErrorCodes) ::= <<

typedef <sTypeDecl> <sName><sArrayPostfix>;

#define <sName>_REQUIRED_BYTES_FOR_ENCODING       <nMaxBytesInPER> 
#define <sName>_REQUIRED_BITS_FOR_ENCODING        <nMaxBitsInPER>
#define <sName>_REQUIRED_BYTES_FOR_ACN_ENCODING   <nMaxBytesInACN> 
#define <sName>_REQUIRED_BITS_FOR_ACN_ENCODING    <nMaxBitsInACN>
#define <sName>_REQUIRED_BYTES_FOR_XER_ENCODING   <nMaxBytesInXER>

void <sName>_Initialize(<sName><sStar> pVal);
flag <sName>_IsConstraintValid(const <sName><sStar> val, int* pErrCode);
<if(bGenEqual)>
flag <sName>_Equal(const <sName><sStar> val1, const <sName><sStar> val2);

<endif>

<arrsErrorCodes;separator="\n">
>>

PrintPrototypes(arrsEncPrototypes) ::= <<
<arrsEncPrototypes: {pr|<pr>}; separator="\n">
>>


PrintErrorCode(sErrorName, nErrCode, sComment) ::= <<
#ifndef <sErrorName> 
#define <sErrorName>		<nErrCode>  /*<sComment>*/
#endif
>>


UPER_encPrototypes(sName, sStar) ::= <<
flag <sName>_Encode(const <sName><sStar> val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag <sName>_Decode(<sName><sStar> pVal, BitStream* pBitStrm, int* pErrCode);
>>

XER_encPrototypes(sName, sStar) ::= <<
flag <sName>_XER_Encode(const <sName><sStar> val, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints);
flag <sName>_XER_Decode(<sName><sStar> pVal, ByteStream* pByteStrm, int* pErrCode);
>>

BER_encPrototypes(sName, sStar) ::= <<
flag <sName>_BER_Encode(const <sName><sStar> val, ByteStream* pByteStrm, int* pErrCode, flag bCheckConstraints);
flag <sName>_BER_Decode(<sName><sStar> pVal, ByteStream* pByteStrm, int* pErrCode);
>>


PrintAcnParameter(sTypeDecl, bEncOut, sName) ::= "<sTypeDecl><if(bEncOut)>*<endif> <sName>"



ACN_encPrototypes(sName, sStar, arrsEncodingParams, arrsDecodingParams) ::= <<
flag <sName>_ACN_Encode(const <sName><sStar> val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints<if(arrsEncodingParams)>, <arrsEncodingParams:{param|<param>}; separator=", "><endif>);
flag <sName>_ACN_Decode(<sName><sStar> pVal, BitStream* pBitStrm, int* pErrCode<if(arrsDecodingParams)>, <arrsDecodingParams:{param|<param>}; separator=", "><endif>);
>>



Declare_Integer() ::="asn1SccSint"
Declare_Integer_min_max(nMin, nMax) ::="asn1SccSint"
Declare_PosInteger_min_max(nMin, nMax) ::="asn1SccUint"
Declare_Integer_posInf(nMin) ::="asn1SccSint"
Declare_PosInteger_posInf(nMin) ::="asn1SccUint"
Declare_Integer_negInf(nMax) ::="asn1SccSint"

Declare_Boolean() ::= "flag"

Declare_Real() ::= "double"

Declare_IA5String() ::= "char"
Declare_NumericString() ::= "char"

Declare_NullType() ::= "NullType"



Declare_BitString(bIsFixeSize, nMaxOctets, nMaxBits) ::= <<
struct {<if(!bIsFixeSize)>
    int nCount; /*Number of bits in the array. Max value is : <nMaxBits> */

<endif>    
    byte arr[<nMaxOctets>];
}
>>

Declare_OctetString(bIsFixeSize, nMaxOctets) ::= <<
struct {<if(!bIsFixeSize)>
    int nCount; 

<endif>    
    byte arr[<nMaxOctets>];
}
>>

PrintNamedItem(sName, nValue) ::= "<sName> = <nValue>"

Declare_Enumerated(arrsItems) ::= <<
enum {
    <arrsItems:{it|<it>}; separator=",\n">
}
>>


PrintSeq_ChoiceChild(sTypeDecl, sName, sArrayPostfix) ::= "<sTypeDecl> <sName><sArrayPostfix>;"

Declare_Choice(sChoiceIDForNone, arrsEnmItems, arrsChildren) ::= <<
struct {
    enum {
        <sChoiceIDForNone>,
        <arrsEnmItems:{ch|<ch>}; separator=",\n"> 
    } kind;
    union {
        <arrsChildren:{ch|<ch>}; separator="\n">
    } u; 
}
>>

Declare_Sequence(arrsChildren, arrsOptionalChildren) ::= <<
struct {
    <arrsChildren:{ch|<ch>}; separator="\n">
    <if (arrsOptionalChildren)>
    struct {
        <arrsOptionalChildren:{ch|unsigned int <ch>:1;}; separator="\n">
    } exist;
    <endif>
}
>>



Declare_SequenceOf(bIsFixedSize, sTypeDecl, nLength, sArrayPostfix) ::= <<
struct {<if(!bIsFixedSize)>
    int nCount; 

<endif>    
    <sTypeDecl> arr[<nLength>]<sArrayPostfix>;
}
>>



