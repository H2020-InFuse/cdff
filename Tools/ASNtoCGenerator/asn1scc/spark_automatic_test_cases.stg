/*
* Copyright (c) 2008-2012 Semantix and (c) 2012-2015 Neuropublic
*
* This file is part of the ASN1SCC tool.
*
* Licensed under the terms of GNU General Public Licence as published by
* the Free Software Foundation.
*
*  For more informations see License.txt file
*/

group spark_automatic_test_cases:spark_spec;


PrintCodecsFile_spec(sModName, arrsIncludedModules, arrsTestFunctions) ::= <<
-- Code automatically generated by asn1scc tool
<arrsIncludedModules:{inc| WITH <inc>;}; separator="\n">
<if(arrsIncludedModules)>
--# inherit <arrsIncludedModules; separator=",">;

<endif>
PACKAGE <sModName>_auto_encs_decs
IS

<arrsTestFunctions; separator="\n\n">

END <sModName>_auto_encs_decs;
>>

PrintCodec_spec(sModName, sTasName, sEnc) ::= "FUNCTION <sTasName>_<sEnc>_enc_dec(val:<sModName>.<sTasName>) RETURN <rtlModuleName()>.TEST_CASE_RESULT;"


PrintCodecsFile_body(sModName, arrsIncludedModules, arrsTasNames, arrsTestFunctions) ::= <<
-- Code automatically generated by asn1scc tool
with Interfaces;
use type Interfaces.Unsigned_8;
with <rtlModuleName()>;
use type <rtlModuleName()>.Asn1UInt;
use type <rtlModuleName()>.Asn1Int;
use type <rtlModuleName()>.BIT;
<arrsIncludedModules:{inc| WITH <inc>; USE <inc>;}; separator="\n">
<arrsTasNames: {tasName|use type <tasName>;}; separator="\n">
PACKAGE BODY <sModName>_auto_encs_decs 
IS 

<arrsTestFunctions; separator="\n\n">

END <sModName>_auto_encs_decs;
>>



Codec_UpdateDecInParam_no_result(sModName, sTasName, sParamName) ::= <<
<sModName>.<sTasName>_ACN_Encode_update_<sParamName>(val,  dec_<sParamName>);
>>

Codec_UpdateDecInParam_with_result(sModName, sTasName, sParamName) ::= <<
<sModName>.<sTasName>_ACN_Encode_update_<sParamName>(val,  dec_<sParamName>, result);
ret := <rtlModuleName()>.TEST_CASE_RESULT'(Step => <rtlModuleName()>.TC_VALIDATE, Success => result.Success, ErrorCode => result.ErrorCode);
>>


Codec_validate_input(sModName, sTasName) ::= <<
-- Check value against ASN.1 constraints
result := <sModName>.<sTasName>_IsConstraintValid(val);
ret := <rtlModuleName()>.TEST_CASE_RESULT'(Step => <rtlModuleName()>.TC_VALIDATE, Success => result.Success, ErrorCode => result.ErrorCode);
>>

Codec_Encode_no_result(sModName, sTasName, sEnc, arrsEncInDecOutParamsNames) ::= <<
-- Encode value
<sModName>.<sTasName>_<sEnc>_Encode(val, stream<if(arrsEncInDecOutParamsNames)>, <arrsEncInDecOutParamsNames:{p| enc_<p>}; separator=", "><endif>);
>>

Codec_Encode_with_result(sModName, sTasName, sEnc, arrsEncInDecOutParamsNames) ::= <<
-- Encode value
<sModName>.<sTasName>_<sEnc>_Encode(val, stream, result<if(arrsEncInDecOutParamsNames)>, <arrsEncInDecOutParamsNames:{p| enc_<p>}; separator=", "><endif>);
ret := <rtlModuleName()>.TEST_CASE_RESULT'(Step => <rtlModuleName()>.TC_DECODE, Success => result.Success, ErrorCode => result.ErrorCode);
>>

Codec_Decode(sModName, sTasName, sEnc, arrsEncParamsNames) ::= <<
-- Decode value
--at this point stream contains the <sEnc> data
<sModName>.<sTasName>_<sEnc>_Decode(decodedPDU, stream, result<if(arrsEncParamsNames)>, <arrsEncParamsNames:{p| dec_<p>}; separator=", "><endif>);
ret := <rtlModuleName()>.TEST_CASE_RESULT'(Step => <rtlModuleName()>.TC_DECODE, Success => result.Success, ErrorCode => result.ErrorCode);
>>

Codec_validate_output(sModName, sTasName) ::= <<
-- validate decoded data
result := <sModName>.<sTasName>_IsConstraintValid(decodedPDU);
ret := <rtlModuleName()>.TEST_CASE_RESULT'(Step => <rtlModuleName()>.TC_VALIDATE_DECODED, Success => result.Success, ErrorCode => result.ErrorCode);
>>

Codec_compare_input_with_output(arrsEncInDecOutParamsNames, sTasName) ::= <<
ret := <rtlModuleName()>.TEST_CASE_RESULT'(Step => <rtlModuleName()>.TC_EQUAL, Success => <sTasName>_Equal(val, decodedPDU)<if(arrsEncInDecOutParamsNames)> AND <arrsEncInDecOutParamsNames:{p| (enc_<p>=dec_<p>)}; separator=" AND "><endif>, ErrorCode => result.ErrorCode);
>>


JoinItems(sPart, bCanFail, sNestedPart) ::= <<
<sPart>
<if(sNestedPart)>
<if(bCanFail)>
IF result.Success THEN
    <sNestedPart>
END IF;
<else>
<sNestedPart>
<endif>
<endif>
>>


Codec_declare_EncInDecOut_variable(sPrmName, sType, sPrmValue) ::= <<
enc_<sPrmName> : CONSTANT <sType> := <sPrmValue>;
dec_<sPrmName> : <sType>;
>>

Codec_declare_DecIn_variable(sPrmName, sType) ::= "dec_<sPrmName> : <sType>;"


PrintCodec_body(sModName, sTasName, sEnc, arrsEncInDecOutParamsLocalVars, arrsDecInParamLocalVars, sNestedStatements) ::= <<
FUNCTION <sTasName>_<sEnc>_enc_dec(val:<sModName>.<sTasName>) RETURN <rtlModuleName()>.TEST_CASE_RESULT
IS
    decodedPDU  : <sModName>.<sTasName>;
    stream      : <sModName>.<sTasName>_<sEnc>_Stream;
    result      : <rtlModuleName()>.ASN1_RESULT;
    ret         : <rtlModuleName()>.TEST_CASE_RESULT;
    <arrsEncInDecOutParamsLocalVars; separator="\n">
    <arrsDecInParamLocalVars; separator="\n">
BEGIN
    <sNestedStatements>
    RETURN ret;
END <sTasName>_<sEnc>_enc_dec;
>>


